Για την υλοποίηση της εργασίας αυτής ***2. Η Newton-Raphson Ξαναχτυπά!*** καθώς και της εργασίας ***2.1 Newton Fractals*** δημιουργήσαμε 2 βασικά αρχεία c. Το ένα (`complexlib.c`) είναι καθαρά υπεύθυνο για την υλοποιήση πράξεων με μιγαδικούς αριθμούς, όπως είναι η πρόσθεση, αφαίρεση, πολλαπλασιαμός, διαίρεσης, υπολογισμός απόλυτης τιμής, ύψωση σε δύναμη και σύγκριση μιγαδικών αριθμών.

Το άλλο αρχείο (`fractal.c`) κάνει τους απαραίτητους υπολογισμούς για να βρει τις μιγαδικές ρίζες των πολυωνύμων και, στην επέκταση του, δημιουργεί μία εικόνα (Newton fractals) με βάση, τόσο το πλήθος των ριζών (=πλήθος διαφορετικών χρωμάτων) όσο και τη συχνότητα εύρεσης αυτών των ριζών (=βάθος χρωμάτων)

Αρχικά, για την εύρεση των ριζών υλοποιούμε τη μέθοδο Newton-Raphson με τη χρήση μίας δομής επανάληψης ```do {...} while (...);``` Η επόμενη ρίζα υπολογίζεται ώς εξής
$z_{n+1} = z_n - \frac{f(z_n)}{f'(z_n)}$
και άρα στη γλώσσα προγραμματισμού C με την εντολή:
```
zn_1 = csub(zn, cdiv(fzn, fdzn));
``` 
όπου ```csub, cdiv``` είναι οι συναρτήσεις που έχουμε υλοποιήσει στο αρχείο ```complexlib.c``` για την αφαίρεση και τη διαίρεση μιγαδικών αριθμών, αντίστοιχα. 

Όταν πλέον έχουμε συγκλίνει σε μία ρίζα ή έχουμε ξεπεράσει τις μέγιστες επαναλήψεις ($1000$) ή φτάσουμε σε διαίρεση με το $0$ τυπώνουμε το αντίστοιχο αποτέλεσμα:
1. Τη ρίζα που βρήκαμε (συγκλίναμε)
2. `incomplete`
3. `nan`

Σε κάθε περίπτωση αποθηκεύουμε όλες τις λύσεις που έχουμε βρει. Στις περιπτώσεις 2, 3 αποθηκεύουμε έναν πολύ μικρό αριθμό ($10^-6$)

`all_solutions[counter] = zn_1;`

Στην $1^η$ περίπτωση, αν η ρίζα αυτή που βρήκαμε δεν έχει ήδη βρεθεί, την αποθηκεύουμε σε έναν ξεχωριστό πίνακα που περιέχει τις διακριτές ρίζες του πολυωνύμου.

`add_if_new(zn_1, sep_solutions, &found);`

Χρειαζόμαστε αυτές τις πληροφορίες ώστε να μπορούμε να παράξουμε σωστά το bmp αρχείο με τα εντυπωσιακά Newton Fractals!

Αφότου γράψουμε τις βασικές πληροφορίες που υπάρχουν σε κάθε header ενός bmp αρχείου προχωράμε στην δημιουργία του πίνακα των pixels.

Πίνακας με 10 διαφορετικά χρώματα για κάθε διακριτή ρίζα των πολυωνύμων (μέχρι 10)
```
int colors[MAX_ROOTS][RGB] = {{0, 0, 255}, {0, 255, 0}, {0, 255, 255}, {255, 0, 0}, {255, 255, 0}, {255, 0, 255}, {64, 0, 128}, {0, 128, 64}, {128, 64, 0}, {0, 0, 0}};
```

Με τις παρακάτω εντολές βάζουμε ένα πολλαπλάσιο των RGB τιμών των παραπάνω χρωμάτων σε κάθε pixel της εικόνας που φτιάχνουμε.

```
val = (log10(loops_arr[width*h+w])-0.3)*colors[index_of(all_solutions[width*h+w], sep_solutions, deg)][r];
fputc((val>255)?255:val, bmp_file);
```

Το αριθμητικό $-0.3$ προέρχεται εμπειρίκα από παρατηρήσεις του αριθμού των επαναλήψεων που απαιτούνται για να συγκλίνει σε μία ρίζα ο αλγόριθμος
Συνήθως ο αριθμός αυτός δεν ξεπερνά το $20$ και επειδή $log_{10}20 \approx 1.3$ αφαιρούμε $0.3$ ώστε να προκύπτει ο πολλαπλασιασμός `1*colors[index][r]` και η τιμή που γράφουμε στο αρχείο μας να μην ξεπερνά το $255$.



Δεν ξεχνάμε το padding (για κάθε γραμμή)
```
for (int p=0; p<padding; p++) {
    fputc(0, bmp_file);
}
```
Και είμαστε έτοιμοι!