Για την επίλυση του προβλήματος χρησιμοποιείται ο αλγόριθμος A* (1).

Συνάρτηση `main()`

    Αρχικά στην συνάρτηση main διαβάζονται και αποθηκεύονται τα δεδομένα και εφόσον είναι έγκυρα, τότε καλείται η συνάρτηση find_moves(). Στο τέλος αποδεσμεύεται και ο πίνακας room.

Συνάρτηση `find_moves()`

Στην αρχή αρχικοποιούνται δύο πίνακες dx και dy, που περιέχουν τις πιθανές θέσεις στην zoomba στους άξονες x και y αντίστοιχα. Μετά δημιουργούναι δύο κόμβοι οι start και goal μέσω της συνάρτησης create_node (θα εξηγηθεί παρακάτω), καθώς επίσης δημιουργείται ένας πίνακας με δείκτες που αντιπροσωπεύσει το σύνολο των ανοιχτών κόμβων προς αξιολόγηση. Η δέσμευση μνήμης γίνεται για n * n κόμβους, ίσο με το πλήθος των θέσεων. Επίσης, δεσμεύεται χώρος για τους πίνακες `closed set`, στον οποίο θα αποθηκεύονται οι κόμβοι που έχουν εξεταστεί, και `visited`, που θα ελέγχουμε αν ένας κόμβος έχει ελεγχθεί. Η δέσμευση χώρου του τελευταίου γίνεται και με την χρήση της calloc, για να μηδενιστούν τα κελιά από την αρχή. Μετά στο `open_set[0]` αποθηκεύεται ο πρώτος κόμβος που είναι η αρχική θέση της zoomba.

Στην επανάληψη while, δημιουργείται ένας κόμβος με την ελάχιστη τιμή της συνάρτησης f από το σύνολο των ανοιχτών κόμβων, μέσω της συνάρτησης `find_min__f`. Η συνάρτηση f είναι το άθροισμα των g και h (εξηγούνται παρακάτω) και είναι το  είναι η συνολική εκτίμηση του "κόστους" του μονοπατιού που διέρχεται από τον κόμβο n, από τον αρχικό κόμβο μέχρι τον στόχο. Στην συνέχεια, ο κόμβος current αποθηκεύεται στον `closed_set` εφόσον πρόκειται να ελεγχθεί, η τιμή του στον πίνακα visited γίνεται 1 και αφαιρείται από την λίστα open_set. Αυτό επιτυγχάνεται διότι ο τελευταίος κόμβος του open_set `open_set[test_size - 1]` αντικαθιστά τον τρέχοντα κόμβο στη θέση k. Αυτό επιτυγχάνεται με τη γραμμή `open_set[k] = open_set[test_size - 1];`. Τέλος, η μεταβλητή `test_size` μειώνεται κατά ένα, ώστε να αντικατοπτρίζει τη νέα διάσταση του `open_set`. 

Στην εμφωλευμένη επανάληψη for της while, Για κάθε δυνατή κίνηση προς τέσσερις κατευθύνσεις, υπολογίζονται οι νέες συντεταγμένες nx και ny του διαδόχου κόμβου. Στη συνέχεια ελέγχεται αν οι νέες συντεταγμένες είναι εντός των ορίων του πεδίου αναζήτησης, αν ο διάδοχος κόμβος δεν αντιστοιχεί σε εμπόδιο στον χώρο και αν ο κόμβος δεν έχει ήδη επισκεφτεί. Αν οι παραπάνω συνθήκες ικανοποιούνται, δημιουργείται ένας νέος κόμβος `successor` με αυξημένο κόστος g κατά 1 σε σχέση με τον τρέχοντα κόμβο και την εκτίμηση (ευκλείδια) της απόστασης προς τον στόχο για τον νέο κόμβο. Στη συνέχεια o successor ελέγχεται αν είναι ο στόχος που ψάχνουμε, αν είναι τότε στον πόνακα moves αποθηκεύεται μέσω της `path` η σειρά των κινήσεων. Διαφορετικά, στην f2 αποθηκεύεται το "κόστος" του successor

Στην επόμενη εμφωλευμένη επανάληψη for της while, αν ο τρέχοντας κόμβος στον πίνακα `open_set` έχει τις ίδιες συντεταγμένες (x, y) με τον successor και αν ναι, ελέγχει αν η τιμή f2 είναι μεγαλύτερη ή ίση με την τιμή f του κόμβου στον πίνακα `open_set`. Αν και οι δύο συνθήκες ισχύουν, τότε ορίζει τη θέση `successor->x, successor->y` στον πίνακα `visited` ως true και διακόπτει την εκτέλεση του βρόχου με τη χρήση της δήλωσης break.
Ουσιαστικά, αυτό το τμήμα κώδικα ελέγχει αν ένας κόμβος έχει ήδη επισκεφτεί και αν ναι, αν η νέα διαδρομή που προσφέρεται είναι καλύτερη από την υπάρχουσα, για να αποφευχθεί η διπλή επίσκεψη σε έναν κόμβο ή η παραγωγή υποβέλτιστων διαδρομών.

Δομή `Node`

Oρίζει έναν τύπο δεδομένων Node, ο οποίος περιέχει ένα σύνολο μεταβλητών, τις x και y που είναι οι συντεταγμένες του κόμβου, την g και την h. H g αντιπροσωπεύει το κόστος του να φτάσει από τον αρχικό κόμβο στον τρέχοντα κόμβο. H h είναι μια εκτίμηση του κόστους για να φτάσει από τον τρέχοντα κόμβο στον στόχο.

Συνάρτηση `euclidean`

Η συνάρτηση euclidean υπολογίζει την ευκλείδεια απόσταση μεταξύ δύο σημείων σε ένα δισδιάστατο χώρο, δεδομένων των συντεταγμένων των δύο σημείων (x1, y1) και (x2, y2). Είνα, δηλαδή, η υποτείνουσα ενός ορθογωνίου τριγώνου.

Συνάρτηση `create_node`

Δημιουργεί έναν κόμβο του γράφου αναζήτησης και τον επιστρέφει. Αυτή η δομή κόμβου περιέχει τις συντεταγμένες του κόμβου στον χάρτη και τις τιμές g και h. Η δέσμευση μνήμης γίνεται με τη χρήση της συνάρτησης malloc, και στη συνέχεια, οι τιμές πεδίων εκχωρούνται στον νέο κόμβο που δημιουργήθηκε.

Συνάρτηση `find_min_`

Η συνάρτηση find_min_f επιστρέφει τον κόμβο από τον πίνακα test που έχει την ελάχιστη τιμή της συνάρτησης f, όπου `f(x) = g(x) + h(x)`. Η συνάρτηση εξετάζει κάθε κόμβο στον πίνακα test και εντοπίζει τον κόμβο με τη μικρότερη τιμή f. Αρχικά, ο πρώτος κόμβος του πίνακα test θεωρείται ο κόμβος με την ελάχιστη τιμή f. Στη συνέχεια, η συνάρτηση ελέγχει τους υπόλοιπους κόμβους του πίνακα, συγκρίνοντας τις τιμές f τους με αυτή του κόμβου που έχει ήδη επιλεγεί. Εάν βρεθεί κάποιος κόμβος με μικρότερη τιμή f, ο κόμβος με τη νέα ελάχιστη τιμή f επιλέγεται ως ο κόμβος με την ελάχιστη τιμή f. Τέλος, η συνάρτηση επιστρέφει τον κόμβο που έχει τη μικρότερη τιμή f. 

Συνάρτηση `path`

Η συνάρτηση ανακατασκευάζει αντίστροφα την διαδρομή από το target προς την αρχή. Αρχικά, δεσμεύεται μνήμη για έναν πίνακα χαρακτήρων που θα αποθηκεύσει τις κινήσεις του path, με βάση το μήκος του path (current->g) και έναν επιπλέον χαρακτήρα για το `\0` και η μεταβλητή `cur` αρχικοποιείται με το μήκος της path. Η while εκτελείται όσο ο τρέχων κόμβος δεν είναι ο αρχικός (δηλαδή όσο δεν έχουμε φτάσει στην αρχή του path). Μέσα στην επανάληψη, ελέγχουμε τη θέση του γονικού κόμβου σε σχέση με τον τρέχοντα κόμβο και αναθέτουμε την κατάλληλη κίνηση (U, D, L, R) στον πίνακα κινήσεων, μείωνοντας τη μεταβλητή cur στη συνέχεια και πηγαίνουμε στον γονικό κόμβο για να συνεχίσουμε την ανακατασκευή του path.

Σημειώσεις:
(1) https://en.wikipedia.org/wiki/A*_search_algorithm