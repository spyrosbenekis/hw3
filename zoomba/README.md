Για την επίλυση του προβλήματος χρησιμοποιείται ο αλγόριθμος A* (1).

Συνάρτηση main()
    Αρχικά στην συνάρτηση main διαβάζεται η είσοδος, αποθηκεύονται τα δεδομένα και εφόσον είναι έγκυρα, τότε καλείται η συνάρτηση fin_moves().

Συνάρτηση find_moves()
    Στην αρχή αρχικοποιούνται δύο πίνακες dx και dy, που περιέχουν τις πιθανές θέσεις στην zoomba στους άξονες x και y αντίστοιχα. Μετά δημιουργούναι δύο κόμβοι οι start και goal μέσω της συνάρτησης create_node (θα εξηγηθεί παρακάτω), καθώς επίσης δημιουργείται ένας δείκτης σε δείκτες (πίνακας) που θα αντιπροσωπεύσει το σύνολο των ανοιχτών κόμβων προς αξιολόγηση. Η δέσμευση μνήμης γίνεται για n * n κόμβους, ίσο με το πλήθος των θέσεων. Επίσης, δεσμεύεται ακόμη ένας δισδιάστατος πίνακας τύπου bool που θα τα 0 και 1 κάθε σημείου. Μετά στο test[0] αποθηκεύεται ο πρώτος κόμβος που είναι η αρχική θέση της zoomba. 
    Στην επανάληψη while, δημιουργείται ένας κόμβος με την ελάχιστη τιμή της συνάρτησης f (2) από το σύνολο των ανοιχτών κόμβων, μέσω της συνάρτησης find_min__f. Στην συνέχεια, ελέγχεται εάν ο επιλεγμένος κόμβος είναι ο στόχος της αναζήτησης. Αν ναι, το πρόγραμμα εκτυπώνει την ακολουθία των κινήσεων που πρέπει να ακολουθήσει το Zoomba για να φτάσει στον στόχο και τερματίζει την εκτέλεσή του. Αυτό γίνεται με την δήλωση της μεταβλητής moves, που είναι ένας δείκτης σε πίνακα χαρακτήρων (char*). Η συνάρτηση reconstruct_path δέχεται έναν κόμβο ως είσοδο (τον τρέχοντα κόμβο) και ανακατασκευάζει τη διαδρομή από τον αρχικό κόμβο μέχρι τον δοθέντα κόμβο, χρησιμοποιώντας την πληροφορία του γονικού κόμβου του κάθε κόμβου. Αυτή η διαδρομή αποθηκεύεται σε έναν πίνακα χαρακτήρων.Όταν εκτελείται η εντολή printf("%s\n", moves);, εκτυπώνετε το περιεχόμενο του πίνακα moves ως συμβολοσειράς χαρακτήρων και η εκτέλεση της συνάρτησης ολοκληρώνετε και συνεχίζει η main.
    Στην εμφωλευμένη επανάληψη for της while, Για κάθε δυνατή κίνηση προς τέσσερις κατευθύνσεις, υπολογίζονται οι νέες συντεταγμένες nx και ny του διαδόχου κόμβου. Στη συνέχεια ελέγχεται αν οι νέες συντεταγμένες είναι εντός των ορίων του πεδίου αναζήτησης και αν ο διάδοχος κόμβος δεν αντιστοιχεί σε εμπόδιο στον χώρο. Αν οι παραπάνω συνθήκες ικανοποιούνται, δημιουργείται ένας νέος κόμβος διαδόχους (successor) με αυξημένο κόστος g κατά 1 σε σχέση με τον τρέχοντα κόμβο και επιλέγεται η εκτίμηση της απόστασης προς τον στόχο για τον νέο κόμβο. Στη συνέχεια ο "επόμενος" κόμβος προστίθεται στο test και η αντίστοιχη θέση του στον πίνακα tested διακρίνεται ως ελεγμένη.
    Στην επόμενη εμφωλευμένη επανάληψη for της while, αφαιρεί τον τρέχοντα κόμβο από το σύνολο των ανοιχτών κόμβων μετά την αξιολόγησή του. Η αφαίρεση γίνεται εξετάζοντας κάθε κόμβο στο σύνολο των ανοιχτών κόμβων και εάν βρεθεί ο τρέχοντας κόμβος, αντικαθιστάται με τον τελευταίο κόμβο του συνόλου και μειώνεται η μεταβλητή test_size κατά ένα. Στη συνέχεια, η θέση του τρέχοντος κόμβου στον πίνακα tested διακρίνεται ως ελεγμένη, ώστε να μην εξεταστεί ξανά στο μέλλον.
    Εφόσον δεν βρεθεί στην while κάποια διαδρομή, τότε σταματάει ο βρόγχος και εκτυπώνεται 0.

Δομή Node
    Oρίζει έναν τύπο δεδομένων Node, ο οποίος περιέχει ένα σύνολο μεταβλητών, τις x και y που είναι οι συντεταγμένες του κόμβου, την g και την h. H g αντιπροσωπεύει το κόστος του να φτάσει από τον αρχικό κόμβο στον τρέχοντα κόμβο. H h είναι μια εκτίμηση του κόστους για να φτάσει από τον τρέχοντα κόμβο στον στόχο.

Συνάρτηση `heuristic`
    H συνάρτηση υπολογίζει την απόσταση manhattan, δηλαδή το άθροισμα των διαφορών των συντεταγμένων, κάθε φορά του τρέχοντος σημείου και του target, σε απόλυτες τιμές. Είναι αλλιώς η ευρετική εκτίμηση για την απόσταση μεταξύ των δύο σημείων.

Συνάρτηση `create_node`
    Δημιουργεί έναν κόμβο του γράφου αναζήτησης και τον επιστρέφει. Αυτή η δομή κόμβου περιέχει τις συντεταγμένες του κόμβου στον χάρτη και τις τιμές g και h. Η δέσμευση μνήμης γίνεται με τη χρήση της συνάρτησης malloc, και στη συνέχεια, οι τιμές πεδίων εκχωρούνται στον νέο κόμβο που δημιουργήθηκε.

Συνάρτηση `find_min_`
    Η συνάρτηση find_min_f επιστρέφει τον κόμβο από τον πίνακα test που έχει την ελάχιστη τιμή της συνάρτησης f, όπου `f(x) = g(x) + h(x)`. Η συνάρτηση εξετάζει κάθε κόμβο στον πίνακα test και εντοπίζει τον κόμβο με τη μικρότερη τιμή f. Αρχικά, ο πρώτος κόμβος του πίνακα test θεωρείται ο κόμβος με την ελάχιστη τιμή f. Στη συνέχεια, η συνάρτηση ελέγχει τους υπόλοιπους κόμβους του πίνακα, συγκρίνοντας τις τιμές f τους με αυτή του κόμβου που έχει ήδη επιλεγεί. Εάν βρεθεί κάποιος κόμβος με μικρότερη τιμή f, ο κόμβος με τη νέα ελάχιστη τιμή f επιλέγεται ως ο κόμβος με την ελάχιστη τιμή f. Τέλος, η συνάρτηση επιστρέφει τον κόμβο που έχει τη μικρότερη τιμή f. 

Συνάρτηση `path`
    Η συνάρτηση ανακατασκευάζει αντίστροφα την διαδρομή από το target προς την αρχή. Αρχικά, δεσμεύεται μνήμη για έναν πίνακα χαρακτήρων που θα αποθηκεύσει τις κινήσεις του path, με βάση το μήκος του path (current->g) και έναν επιπλέον χαρακτήρα για το `\0` και η μεταβλητή `cur` αρχικοποιείται με το μήκος της path. Η while εκτελείται όσο ο τρέχων κόμβος δεν είναι ο αρχικός (δηλαδή όσο δεν έχουμε φτάσει στην αρχή του path). Μέσα στην επανάληψη, ελέγχουμε τη θέση του γονικού κόμβου σε σχέση με τον τρέχοντα κόμβο και αναθέτουμε την κατάλληλη κίνηση (U, D, L, R) στον πίνακα κινήσεων, μείωνοντας τη μεταβλητή cur στη συνέχεια και πηγαίνουμε στον γονικό κόμβο για να συνεχίσουμε την ανακατασκευή του path.